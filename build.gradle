buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath "org.ajoberstar:gradle-git:1.4.2"
        classpath "com.github.marceloemanoel:gradle-environments-plugin:0.1"
        classpath "org.hidetake:gradle-ssh-plugin:2.0.0"
    }
}

plugins {
    id 'org.hidetake.ssh' version '1.6.0'
}

import org.ajoberstar.grgit.*
import groovy.io.FileType

apply plugin: "java"
apply plugin: "war"
apply plugin: "idea"
apply plugin: "environments"
apply plugin: "org.hidetake.ssh"

targetCompatibility = 1.7
sourceCompatibility = 1.7

repositories {
    mavenCentral()
}


//noinspection GroovyAssignabilityCheck
configurations {
    provided
    server
}

idea {
    module {
        scopes.COMPILE.plus += [configurations.server]
        scopes.PROVIDED.plus += [configurations.provided]
    }
}

//noinspection GroovyAssignabilityCheck
sourceSets {
    main {
        compileClasspath += [configurations.server]
        compileClasspath += [configurations.provided]
    }
    test {
        compileClasspath += [configurations.server]
        runtimeClasspath += [configurations.server]
    }
}

dependencies {
    compile project(":biocode-fims-commons")
    compile project(":biocode-fims-fuseki")
    provided 'org.eclipse.jetty:jetty-servlet:9.3.3.v20150827'

    server('org.glassfish.jersey.ext:jersey-spring3:2.22.2') {
        exclude module: 'bean-validator'
    }

    testCompile "junit:junit-dep:4.10"
}

webAppDirName = "src/main/web"
libsDirName = "../dist"
project.ext.environment = defaultEnvironment

//noinspection GroovyAssignabilityCheck
clean {
    delete libsDir
}

// jetty ssh plugin
remotes {
    biscicol {
        host = 'biscicol.org'
        user = biscicolUser
        password = biscicolPassword
    }
}

allprojects {
    task verifyMasterBranch(overwrite: true) << {
        ext.repo = Grgit.open(project.file('.'))
        if (ext.repo.branch.current.name != "master")
            throw new GradleScriptException(project.name + ' is not on the master branch', null)
    }
}

task setProductionEnv << {
    project.ext.environment = "production"
}
task setDevelopmentEnv << {
    project.ext.environment = "development"
}
task setLocalEnv << {
    project.ext.environment = "development"
}


// if setProductionEnv or setDevelopmentEnv is run, make sure this is done before processResources
setProductionEnv.mustRunAfter compileJava
setDevelopmentEnv.mustRunAfter compileJava
setLocalEnv.mustRunAfter compileJava

/*
Delete any resource files in src/main/resources if the file exists in a sub directory
of src/main/environment, excluding the current environment setting directory
*/
task cleanResourceDirectory {
    doLast {
        def allResourceFilesToRemove = []

        def environmentDir = new File("src/main/environment")
        environmentDir.eachFileRecurse(FileType.FILES) { file ->
            allResourceFilesToRemove << file.name
        }

        allResourceFilesToRemove.each {
            def resourceFile = new File("src/main/resources/${it}")
            if (resourceFile.exists()) {
                resourceFile.delete()
            }
        }
    }
}

task copyEnvironmentResources {
    dependsOn cleanResourceDirectory
    doLast {
        project.copy {
            from "src/main/environment/${project.environment}"
            into "src/main/resources"
            include "**/*"
            exclude "web.xml"
            exclude ".gitkeep"
        }
    }
}
processResources.dependsOn copyEnvironmentResources

task copyWebXml {
    inputs.dir "src/main/environment/${project.environment}/web.xml"
    outputs.dir "src/main/web/WEB-INF"
    doLast {
        project.copy {
            from "src/main/environment/${project.environment}"
            into "src/main/web/WEB-INF"
            include "web.xml"
        }
    }
}

processResources.dependsOn copyWebXml

task restartFims {
    group = 'biscicol.org'
    description = 'Restart biscicol.org production jetty instance'
    doLast {
        ssh.run {
            session(remotes.biscicol) {
                executeSudo biscicolJettyPath + ' restart'
            }
        }
    }
}

task restartFimsDev  {
    group = 'biscicol.org'
    description = 'Restart biscicol.org dev jetty instance'
    doLast {
        ssh.run {
            session(remotes.biscicol) {
                executeSudo biscicolJettyDevPath + ' restart'
            }
        }
    }
}

/**
 * add all dependencies of scope "server" to the compile scope
 */
task addDependenciesToWar << {
    // work around from project.configurations.server as custom scopes aren't propagated to parent project
    for (p in project.getSubprojects()) {
        project.configurations.compile.dependencies.addAll(p.configurations.server.dependencies)
    }
    project.configurations.compile.dependencies.addAll(project.configurations.server.dependencies)
}


ext.getDependencyFiles = {
    def subProjectJars = []
    def dependencyFiles = []

    // get a list of the sub project jars to exclude as subProjects should be built at the same time as this project.
    for (p in project.getSubprojects()) {
        subProjectJars.add(p.jar.archiveName)
    }

    // work around from project.configurations.server.incoming.getFiles() as custom scopes aren't propagated to parent
    // project
    for (p in project.getSubprojects()) {
        for (dependency in p.configurations.server.incoming.getFiles()) {
            if (!subProjectJars.contains(dependency.getName()) &&
                    !dependencyFiles.contains(dependency.absoluteFile)) {
                dependencyFiles.add(dependency.absoluteFile)
            }
        }
    }
    for (dependency in project.configurations.server.incoming.getFiles()) {
        if (!subProjectJars.contains(dependency.getName())) {
            dependencyFiles.add(dependency.absoluteFile)
        }
    }
    return dependencyFiles
}

ext.updateRemoteDependencies = { location ->
    def files = getDependencyFiles()

    ssh.run {
        session(remotes.biscicol) {
            execute "/bin/rm -f "+ location + "*"
            put from: files, into: location
        }
    }
}

task updateDependenciesDev {
    group = "biscicol.org"
    description = "update the jars located in " + remoteDevLibsDirectory

    doLast {
        updateRemoteDependencies(remoteDevLibsDirectory)
    }
}

task updateDependencies {
    group = "biscicol.org"
    description = "update the jars located in " + remoteLibsDirectory

    dependsOn verifyMasterBranch

    doLast {
        updateRemoteDependencies(remoteLibsDirectory)
    }
}

ext.remoteDeploy = { workingDir, remoteLibsDir, remoteWarDir ->
    ssh.run {
        session(remotes.biscicol) {
            // Cleanup to begin
            execute "/bin/rm -rf " + workingDir
            execute "/bin/mkdir " + workingDir
            // Copy war file to server
            put from: war.archivePath.path, into: workingDir
            // Extract libs and copy from server
            execute "/usr/bin/unzip -d " + workingDir + " " + workingDir + war.archiveName
            execute "/bin/cp " + remoteLibsDir + "* " + workingDir + "WEB-INF/lib/"
            // Remove the old war file
            execute "/bin/rm " + workingDir + war.archiveName
            // Need to remove the war file itself-- we instead just copy it into /tmp for safekeeping in case next step fails
            execute "/bin/mv " + remoteWarDir + "dipnet.war" + " /tmp/dipnet.deployed.war.backup"
            // Need to execute zip command from the working Directory in order to get relative paths correct
            execute "cd " + workingDir + ";/usr/bin/zip -r " + remoteWarDir + "dipnet.war " + " ."
            // Cleanup
            execute "/bin/rm -rf " + workingDir
            execute "/bin/rm /tmp/dipnet.deployed.war.backup"
        }
    }
}

task deployFims {
    group = 'biscicol.org'
    description = 'verify that all subprojects are on the master branch. Then build and copy war to biscicol.org production jetty webApp directory'

    dependsOn verifyMasterBranch
    dependsOn setProductionEnv
    dependsOn war

    doLast {
        def workingDir = "/tmp/dipnetProd/"
        remoteDeploy(workingDir, remoteLibsDirectory, remoteWarDirectory)
    }
}

task deployFimsDev {
    group = 'biscicol.org'
    description = 'build and copy war to biscicol.org development jetty webApp directory'

    dependsOn setDevelopmentEnv
    dependsOn war

    doLast {
        def workingDir = "/tmp/dipnetDev/"
        remoteDeploy(workingDir, remoteDevLibsDirectory, remoteWarDevDirectory)

    }
}

task deployFimsLocal {
    description = 'local dipnet fims deployment'

    dependsOn setLocalEnv
    dependsOn addDependenciesToWar
    dependsOn war

    doLast {
        project.copy {
            from war.destinationDir
            into localWarDirectory
            include war.archiveName
            rename war.archiveName, "dipnet.war"
        }
    }
}
